//###########################################################################
// Description:
//
//
//###########################################################################


#include "F28x_Project.h"
#include "Configuration.h"
#include "cla_shared.h"
#include "Encoder.h"
#include "motion.h"


// Core engine
#ifdef USE_FLOATING_POINT
    //float feed;
    float previousFeed;
#else
    const FEED_THREAD *feed;
    const FEED_THREAD *previousFeed;
#endif // USE_FLOATING_POINT

int16 previousFeedDirection;
Uint32 previousSpindlePosition;

// Stepper driver stuff
int32 currentPosition; // Current position of the motor, in steps
int32 desiredPosition; // Desired position of the motor, in steps
Uint16 state; // State machine state (bit 1 = DIR, bit 0 = STEP)
bool stepperEnabled; // Drive enable

// Encoder stuff
Uint32 previous;
Uint16 rpm;

Uint16 getRPM(void);
inline int32 feedRatio(Uint32);

//Task 1 :
__attribute__((interrupt))  void Cla1Task1 ( void )
{
    if (powerOn) {  GPIO_SET_ENABLE; } else { GPIO_CLEAR_ENABLE; }

    if( feed != NULL ) {

        // read the encoder
        Uint32 spindlePosition = EQep1Regs.QPOSCNT; //ENCODER_REGS.QPOSCNT;

        // calculate the desired stepper position
        int32 desiredSteps = feedRatio(spindlePosition);
        desiredPosition = desiredSteps;

        // compensate for encoder overflow/underflow
        if( spindlePosition < previousSpindlePosition && previousSpindlePosition - spindlePosition > _ENCODER_MAX_COUNT/2 ) {
            currentPosition += -1 * feedRatio(_ENCODER_MAX_COUNT);
        }
        if( spindlePosition > previousSpindlePosition && spindlePosition - previousSpindlePosition > _ENCODER_MAX_COUNT/2 ) {
            currentPosition += feedRatio(_ENCODER_MAX_COUNT);
        }

        // if the feed or direction changed, reset sync to avoid a big step
        if( feed != previousFeed || feedDirection != previousFeedDirection) {
            currentPosition = desiredSteps;
        }

        // remember values for next time
        previousSpindlePosition = spindlePosition;
        previousFeedDirection = feedDirection;
        previousFeed = feed;

        rpm_out = getRPM();

        // service the stepper drive state machine
        if(stepperEnabled) {

            switch( state ) {

            case 0:
                // Step = 0; Dir = 0
                if( desiredPosition < currentPosition ) {
                    GPIO_SET_STEP;
                    state = 2;
                }
                else if( desiredPosition > currentPosition ) {
                    GPIO_SET_DIRECTION;
                    state = 1;
                }
                break;

            case 1:
                // Step = 0; Dir = 1
                if( desiredPosition > currentPosition ) {
                    GPIO_SET_STEP;
                    state = 3;
                }
                else if( desiredPosition < currentPosition ) {
                    GPIO_CLEAR_DIRECTION;
                    state = 0;
                }
                break;

            case 2:
                // Step = 1; Dir = 0
                GPIO_CLEAR_STEP;
                currentPosition--;
                state = 0;
                break;

            case 3:
                // Step = 1; Dir = 1
                GPIO_CLEAR_STEP;
                currentPosition++;
                state = 1;
                break;
            }

        } else {
            // not enabled; just keep current position in sync
            currentPosition = desiredPosition;
        }
    }
    EPwm1Regs.ETCLR.bit.INT = 1; // Clear ePWM1 interrupt flag to allow the next interrupt
}

// Task 8: initialize things
__attribute__((interrupt))  void Cla1Task8 ( void )
{
    // Initialize local variables & IO state
    currentPosition = 0;
    desiredPosition = 0;
    state = 0;

    __meallow();
    GPIO_CLEAR_STEP;
    GPIO_CLEAR_DIRECTION;
    __medis();

    stepperEnabled = true;

    previousSpindlePosition = 0;
    previousFeedDirection = 0;
    previousFeed = NULL;

    powerOn = true; // default to power on
}

Uint16 getRPM(void)
{
    if(ENCODER_REGS.QFLG.bit.UTO==1)       // If unit timeout (one 10Hz period)
    {
        Uint32 current = ENCODER_REGS.QPOSLAT;
        Uint32 count = (current > previous) ? current - previous : previous - current;

        // deal with over/underflow
        if( count > _ENCODER_MAX_COUNT/2 ) {
            count = _ENCODER_MAX_COUNT - count; // just subtract from max value
        }

        rpm = count * 60 * RPM_CALC_RATE_HZ / ENCODER_RESOLUTION;

        previous = current;
        ENCODER_REGS.QCLR.bit.UTO=1;       // Clear interrupt flag
    }

    return rpm;
}

inline int32 feedRatio(Uint32 count)
{
#ifdef USE_FLOATING_POINT
    return ((float)count) * feed * feedDirection;
#else // USE_FLOATING_POINT
    return ((long long)count) * feed->numerator / feed->denominator * feedDirection;
#endif // USE_FLOATING_POINT
}
